<!DOCTYPE html>
<html>
<head>
	<title>Fluorine</title>
	<style>
		::-webkit-scrollbar {
			width: 10px;
		}
		::-webkit-scrollbar-track {
			background-color: #eaeaea;
			border-left: 1px solid #ccc;
		}
		::-webkit-scrollbar-thumb {
			background-color: #aaa;
		}
		::-webkit-scrollbar-thumb:hover {
		background-color: #999;
		}
	
		body {
			margin: 0;
			border: 0;
			padding: 0;
			background-color: black;
			color: white;
			user-select: none;
			cursor: default;
			overflow: hidden;
		}

		.left {
			position: relative;
			top: 0;
			left: 1em;
		}

		.right {
			position: absolute;
			top: 0;
			right: 0;
		}
		
		.lower { 
			bottom: 0;
			overflow-y: auto;
			overflow-x: hidden;
			height: 360px;
			width: 30%
		}

		#canvas {
			background-color: black;
		}

	</style>
</head>
<body>

<div class="left" id="infobox"></div>
<div class="left lower" id="content"></div>

<canvas class="right" id="canvas"></canvas>

<script>

	"use strict";

	const alert = require("./modules/alert");
	const fs = require("fs");
	const ipcRenderer = require("electron").ipcRenderer;
	const path = require("path");
	const stream = require("stream");
	const zstd = require("node-zstandard");

	const TURN_REGEX = /^T:\s*(\d+)(.*)/
	const SHIP_REGEX = /^S:\s*(\d+)(.*)/
	const colours = ["#eeaaee", "#63ceca", "#ffbe00", "#c5ec98"];
	const ranks = ["???", "1st", "2nd", "3rd", "4th"];

	const canvas = document.getElementById("canvas");
	const infobox = document.getElementById("infobox");

	const context = canvas.getContext("2d");

	function make_renderer() {

		let renderer = Object.create(null);

		renderer.game = null;
		renderer.filename = "";
		renderer.turn = 0;
		renderer.selection = null;
		renderer.width = 0;
		renderer.height = 0;
		renderer.production_maps = null;
		renderer.dropoff_list = null;
		renderer.sid_pid_map = null;

		renderer.integer_box_sizes = false;
		renderer.triangles_show_next = true;
		renderer.offset_x = 0;
		renderer.offset_y = 0;

		// --------------------------------------------------------------

		renderer.open = (filename) => {

			console.log(`Trying to load ${filename}`);

			let ok = renderer.open_simple(filename);

			if (!ok) {
				if (filename.endsWith(".json") === false) {
					renderer.open_zstd(filename);
				} else {
					console.log("Loading failed (simple JSON).");
					alert("Couldn't open this file.");
				}
			}
		};

		renderer.open_simple = (filename) => {

			// Returns false if it wasn't plain JSON.
			// Blocks while reading.

			try {
				let contents = fs.readFileSync(filename);
				renderer.game = JSON.parse(contents);
			} catch (err) {
				return false;
			}

			renderer.finish_load(filename);
			return true;
		};

		renderer.open_zstd = (filename) => {

			let warned = false;
			let all_chunks = [];
			let loading_stream = new stream.Writable();

			loading_stream._write = (chunk, encoding, done) => {
				all_chunks.push(chunk.toString());
				done();
			};

			// I believe the following is async (event loopy)...

			zstd.decompressFileToStream(filename, loading_stream, (err, result) => {
				if (err) {
					console.log("Loading failed (a).");
					if (!warned) {
						alert("Couldn't open this file.");
						warned = true;
					}
				}
				result.on("error", (err) => {
					console.log("Loading failed (b).");
					if (!warned) {
						alert("Couldn't open this file.");
						warned = true;
					}
				});
				result.on("finish", () => {
					try {
						renderer.game = JSON.parse(all_chunks.join(""));
					} catch (new_err) {
						console.log("Loading failed (c).");
						if (!warned) {
							console.log(new_err);
							alert("Couldn't open this file.");
							warned = true;
						}
						return;		// So finish_load() isn't called.
					}
					renderer.finish_load(filename);
				});
			});
		};

		renderer.finish_load = (filename) => {

			console.log("Loading seemed OK.");

			renderer.filename = filename;
			renderer.turn = 0;
			renderer.selection = null;
			renderer.width = renderer.game.production_map.width;
			renderer.height = renderer.game.production_map.height;

			renderer.offset_x = 0;
			renderer.offset_y = 0;

			renderer.make_production_maps();
			renderer.make_dropoff_list();
			renderer.make_sid_pid_map();

			renderer.set_title();
			renderer.log_load()
			renderer.draw();
		};
		
		renderer.log_load = () => {
			renderer.logs = {}
			let filename = renderer.filename.replace(/\.(hlt|json)$/, ".log")
			try {
				let data = fs.readFileSync(filename);
				data = data.toString().split("\n");
				
				for (let i in data) {
					let turn_match = TURN_REGEX.exec(data[i]);
					if (turn_match) {
						let turn = parseInt(turn_match[1], 10);
						if (renderer.logs[turn] === undefined ) {
							renderer.logs[turn] = {};
						}
						let ship_match = SHIP_REGEX.exec(turn_match[2]);
						var line = turn_match[2];
						var ship = -1;
						if (ship_match) {
							ship = parseInt(ship_match[1], 10);
							line = ship_match[2];
						}
						if (renderer.logs[turn][ship] === undefined ) {
							renderer.logs[turn][ship] = [];
						}
						if (line.length > 40) {
							line = line.substring(0, 37) + "..."
						}
						renderer.logs[turn][ship].push(line);
					}
				}
			} catch (err) {
				renderer.logs = null;
			}
		}

		renderer.set_title = () => {

			if (!renderer.game) {
				document.title = "Fluorine";
				return;
			}

			let player_names = [];

			for (let pid = 0; pid < renderer.players(); pid++) {
				player_names.push(renderer.game.players[pid].name);
			}

			document.title = player_names.join(" - ");
		};

		// --------------------------------------------------------------

		renderer.make_sid_pid_map = () => {

			renderer.sid_pid_map = Object.create(null);

			for (let n = 0; n < renderer.game_length(); n++) {

				let frame = renderer.frame(n);
				let events = frame.events;

				for (let i = 0; i < events.length; i++) {
					let event = events[i];
					if (event.type === "spawn") {
						renderer.sid_pid_map[event.id] = event.owner_id;
					}
				}
			}
		};

		renderer.make_production_maps = () => {

			if (!renderer.game) {
				renderer.production_maps = null;
				return;
			}

			renderer.production_maps = [];			// Format is [turn][x][y]

			// Make frame 0 map...

			renderer.production_maps.push([]);
			for (let x = 0; x < renderer.width; x++) {
				renderer.production_maps[0].push([]);
				for (let y = 0; y < renderer.height; y++) {
					renderer.production_maps[0][x].push(renderer.game.production_map.grid[y][x].energy);	// Note reversed coords in JSON
				}
			}

			// Make the rest...

			for (let n = 1; n < renderer.game_length(); n++) {

				// Make this frame identical to the one before...

				renderer.production_maps.push([]);
				for (let x = 0; x < renderer.width; x++) {
					renderer.production_maps[n].push([]);
					for (let y = 0; y < renderer.height; y++) {
						renderer.production_maps[n][x].push(renderer.production_maps[n - 1][x][y]);
					}
				}

				// And now adjust for mining...

				let prior_frame = renderer.frame(n - 1);		// Can't use renderer.previous_frame() since turn isn't set

				for (let c = 0; c < prior_frame.cells.length; c++) {

					let cell = prior_frame.cells[c];

					let x = cell.x;
					let y = cell.y;
					let val = cell.production;

					renderer.production_maps[n][x][y] = val;
				}
			}
		};

		renderer.make_dropoff_list = () => {

			if (!renderer.game) {
				renderer.dropoff_list = null;
				return;
			}

			renderer.dropoff_list = [];

			for (let n = 0; n < renderer.game_length(); n++) {

				for (let i = 0; i < renderer.frame(n).events.length; i++) {

					let event = renderer.frame(n).events[i];

					if (event.type === "construct") {

						let d = Object.create(null);
						d.x = event.location.x;
						d.y = event.location.y;
						d.pid = event.owner_id;
						d.turn = n;

						renderer.dropoff_list.push(d);
					}
				}
			}
		};

		// --------------------------------------------------------------

		renderer.save = (filename) => {
			if (!filename || !renderer.game) return;
			fs.writeFileSync(filename, JSON.stringify(renderer.game, null, "\t"));
		};

		renderer.save_frame = (filename) => {
			if (!filename || !renderer.game) return;
			fs.writeFileSync(filename, JSON.stringify(renderer.current_frame(), null, "\t"));
		};

		renderer.save_entities = (filename) => {
			if (!filename || !renderer.game) return;
			fs.writeFileSync(filename, JSON.stringify(renderer.current_frame().entities, null, "\t"));
		};

		renderer.save_moves = (filename) => {
			if (!filename || !renderer.game) return;
			fs.writeFileSync(filename, JSON.stringify(renderer.current_frame().moves, null, "\t"));
		};

		// --------------------------------------------------------------

		renderer.forward = (n) => {		// Negative arguments are allowed (go back).

			if (!renderer.game) return;

			renderer.turn += n;
			if (renderer.turn < 0) renderer.turn = 0;
			if (renderer.turn >= renderer.game_length()) renderer.turn = renderer.game_length() - 1;

			renderer.draw();
		};

		renderer.right = (n) => {
			renderer.offset_x += n;
			renderer.draw();
		};

		renderer.down = (n) => {
			renderer.offset_y += n;
			renderer.draw();
		};

		renderer.toggle = (varname) => {
			renderer[varname] = !renderer[varname];
			renderer.draw();
		};

		renderer.set = (varname, value) => {
			renderer[varname] = value;
			renderer.draw();
		};

		// --------------------------------------------------------------

		renderer.collision_at = (x, y) => {

			// Returns the event from the previous frame, or null if not found...

			let events = renderer.previous_frame().events;

			for (let n = 0; n < events.length; n++) {
				if (events[n].type === "shipwreck") {
					if (x === events[n].location.x && y === events[n].location.y) {
						return events[n];
					}
				}
			}

			return null;
		};

		renderer.collision_involving_ship = (sid) => {

			// Returns the event from the previous frame, or null if not found...

			let events = renderer.previous_frame().events;

			for (let n = 0; n < events.length; n++) {
				if (events[n].type === "shipwreck") {
					for (let i = 0; i < events[n].ships.length; i++) {
						if (events[n].ships[i] === sid) {
							return events[n];
						}
					}
				}
			}

			return null;
		};

		// --------------------------------------------------------------

		renderer.box_string = (x, y, highlight_flag) => {
			let val = renderer.production_maps[renderer.turn][x][y];
			if (highlight_flag) {
				return `[${x}, ${y}] &ndash; ${val}`;
			} else {
				return `${x}, ${y} &ndash; ${val}`;
			}
		};

		renderer.box_with_ship_string = (sid, highlight_box_flag) => {

			let ship_info = renderer.ship_info(sid);

			if (ship_info === null) {
				let cause = renderer.turn < renderer.selection.turn ? "not yet present" : "no longer present";
				return `<span style="color: ${colours[renderer.selection.pid]};">Ship ${renderer.selection.sid}</span> (${cause})`;
			}

			let colour = colours[ship_info.pid];
			let mark = ship_info.is_inspired ? "+" : "";

			if (highlight_box_flag) {

				return `${renderer.box_string(ship_info.x, ship_info.y, true)}`
						+ ` &ndash; <span style="color: ${colour};">Ship ${sid}${mark}</span>`
						+ ` &ndash; <span style="color: ${colour};">${ship_info.energy}</span>`
						+ ` &ndash; next is <span style="color: ${colour};">${renderer.ship_move(sid)}</span>`;

			} else {

				return `${renderer.box_string(ship_info.x, ship_info.y, false)}`
						+ ` &ndash; <span style="color: ${colour};">[Ship ${sid}${mark}]</span>`
						+ ` &ndash; <span style="color: ${colour};">${ship_info.energy}</span>`
						+ ` &ndash; next is <span style="color: ${colour};">${renderer.ship_move(sid)}</span>`;
			}
		};

		renderer.collision_string = (event) => {

			let sids = [];

			for (let n = 0; n < event.ships.length; n++) {
				sids.push(event.ships[n]);
			}

			sids.sort((a, b) => {
				return a - b;
			});

			let string_list = [];

			for (let n = 0; n < sids.length; n++) {
				let sid = sids[n];
				let pid = renderer.sid_pid_map[sid];
				string_list.push(`<span style="color: ${colours[pid]}">${sid}</span>`);
			}

			return `<span style="color: #ff0000">Collision</span>: ${string_list.join(", ")}`;
		};

		renderer.selection_string = () => {

			if (!renderer.selection) {
				return "no selection";
			}

			if (renderer.selection.type === "box") {

				let x = renderer.selection.x;
				let y = renderer.selection.y;

				let collision = renderer.collision_at(x, y);

				if (collision) {
					return `${renderer.box_string(x, y, true)} &ndash; ${renderer.collision_string(collision)}`;
				} else {
					let ship_info = renderer.ship_at(x, y);
					if (ship_info) {
						return renderer.box_with_ship_string(ship_info.sid, true);
					}
					return `${renderer.box_string(x, y, true)}`;
				}
			}

			if (renderer.selection.type === "ship") {

				let sid = renderer.selection.sid;

				let collision = renderer.collision_involving_ship(sid);

				if (collision) {
					let x = collision.location.x;
					let y = collision.location.y;
					return `${renderer.box_string(x, y)} &ndash; ${renderer.collision_string(collision)}`;
				}

				return renderer.box_with_ship_string(sid, false);
			}
		};

		// --------------------------------------------------------------

		renderer.offset_adjust = (x, y, undo_flag) => {

			// Given coords x, y, return x, y adjusted by current offset.

			if (!renderer.game) return [x, y];

			if (!undo_flag) {
				x += renderer.offset_x;
				y += renderer.offset_y;
			} else {
				x -= renderer.offset_x;
				y -= renderer.offset_y;
			}

			// Sneaky modulo method which works for negative numbers too...
			// https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e

			x = (x % renderer.width + renderer.width) % renderer.width;
			y = (y % renderer.height + renderer.height) % renderer.height;

			return [x, y];
		};

		// --------------------------------------------------------------

		renderer.clear = () => {

			if (!renderer.game) {
				context.clearRect(0, 0, canvas.width, canvas.height);
				return;
			}

			let desired_size;

			if (!renderer.integer_box_sizes) {
				desired_size = Math.max(1 * renderer.height, window.innerHeight);
			} else {
				desired_size = Math.max(1, Math.floor(window.innerHeight / renderer.height)) * renderer.height;
			}

			if (desired_size !== canvas.width || desired_size !== canvas.height) {
				canvas.width = desired_size;
				canvas.height = desired_size;
			}

			context.clearRect(0, 0, canvas.width, canvas.height);
		};

		renderer.draw = () => {

			renderer.clear();

			if (!renderer.game) {
				return;
			}

			renderer.draw_grid();
			renderer.draw_structures();
			renderer.draw_ships();
			renderer.draw_collisions();
			renderer.draw_selection_crosshairs();

			renderer.log_lines();
			renderer.send_info();
		};

		renderer.draw_grid = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			for (let x = 0; x < renderer.width; x++) {

				for (let y = 0; y < renderer.height; y++) {

					let val = Math.floor(renderer.production_maps[renderer.turn][x][y] / 4);
					val = Math.min(255, val);

					context.fillStyle = `rgb(${val},${val},${val})`;
					let [i, j] = renderer.offset_adjust(x, y);
					context.fillRect(i * box_width, j * box_height, box_width, box_height);
				}
			}
		};

		renderer.draw_structures = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			for (let pid = 0; pid < renderer.players(); pid++) {

				let x = renderer.game.players[pid].factory_location.x;
				let y = renderer.game.players[pid].factory_location.y;

				context.fillStyle = colours[pid];
				let [i, j] = renderer.offset_adjust(x, y);
				context.fillRect(i * box_width, j * box_height, box_width, box_height);
				context.fillStyle = "#000000";
				context.fillRect(i * box_width + box_width / 4, j * box_height + box_height / 4, box_width / 2, box_height / 2);
			}

			for (let n = 0; n < renderer.dropoff_list.length; n++) {

				if (renderer.dropoff_list[n].turn >= renderer.turn) {
					continue;
				}

				let x = renderer.dropoff_list[n].x;
				let y = renderer.dropoff_list[n].y;
				let pid = renderer.dropoff_list[n].pid;

				context.fillStyle = colours[pid];
				let [i, j] = renderer.offset_adjust(x, y);
				context.fillRect(i * box_width, j * box_height, box_width, box_height);
				context.fillStyle = "#000000";
				context.fillRect(i * box_width + box_width / 4, j * box_height + box_height / 4, box_width / 2, box_height / 2);
			}
		};

		renderer.get_moves_map = (next_flag) => {

			// All moves stored in previous/current frame, as a map of sid --> direction

			let ret = Object.create(null);

			let frame;

			if (next_flag) {
				frame = renderer.current_frame();
			} else {
				frame = renderer.previous_frame();
			}

			for (let pid = 0; pid < renderer.players(); pid++) {
				let some_moves = frame.moves[pid];
				if (some_moves === undefined) {
					continue;
				}
				for (let n = 0; n < some_moves.length; n++) {
					let move = some_moves[n];
					if (move.type === "m") {
						ret[move.id] = move.direction;
					}
				}
			}
			return ret;
		};

		renderer.draw_ships = () => {

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();
			let frame = renderer.current_frame();

			let moves_map = renderer.get_moves_map(renderer.triangles_show_next);

			for (let pid = 0; pid < renderer.players(); pid++) {

				let colour = colours[pid];

				let some_ships = frame.entities[pid];

				if (some_ships === undefined) {
					continue;
				}

				for (let [sid, ship] of Object.entries(some_ships)) {

					let x = ship.x;
					let y = ship.y;

					context.fillStyle = colour;
					let [i, j] = renderer.offset_adjust(x, y);

					switch (moves_map[sid]) {
						case "n":
							context.beginPath();
							context.moveTo(i * box_width, (j + 1) * box_height);
							context.lineTo((i + 1) * box_width, (j + 1) * box_height);
							context.lineTo((i + 0.5) * box_width, j * box_height);
							context.fill();
							break;
						case "s":
							context.beginPath();
							context.moveTo(i * box_width, j * box_height);
							context.lineTo((i + 1) * box_width, j * box_height);
							context.lineTo((i + 0.5) * box_width, (j + 1) * box_height);
							context.fill();
							break;
						case "e":
							context.beginPath();
							context.moveTo(i * box_width, j * box_height);
							context.lineTo(i * box_width, (j + 1) * box_height);
							context.lineTo((i + 1) * box_width, (j + 0.5) * box_height);
							context.fill();
							break;
						case "w":
							context.beginPath();
							context.moveTo((i + 1) * box_width, j * box_height);
							context.lineTo((i + 1) * box_width, (j + 1) * box_height);
							context.lineTo(i * box_width, (j + 0.5) * box_height);
							context.fill();
							break;
						default:
							context.fillRect(i * box_width + box_width / 4, j * box_height + box_height / 4, box_width / 2, box_height / 2);
					}
				}
			}
		};

		renderer.draw_collisions = () => {

			if (renderer.turn <= 0) return;

			let box_width = renderer.box_width();
			let box_height = renderer.box_height();

			let events = renderer.previous_frame().events;

			for (let n = 0; n < events.length; n++) {

				if (events[n].type === "shipwreck") {

					let x = events[n].location.x;
					let y = events[n].location.y;

					context.fillStyle = "#ff0000";
					let [i, j] = renderer.offset_adjust(x, y);
					context.fillRect(i * box_width, j * box_height, box_width, box_height);
				}
			}
		};

		renderer.draw_selection_crosshairs = () => {

			let x;
			let y;

			if (!renderer.selection) {

				return;

			} else if (renderer.selection.type === "box") {

				x = renderer.selection.x;
				y = renderer.selection.y;

			} else if (renderer.selection.type === "ship") {

				let info = renderer.ship_info(renderer.selection.sid);

				if (info) {

					x = info.x;
					y = info.y;

				} else {

					// Ship doesn't currently exist, was it just destroyed?

					let collision = renderer.collision_involving_ship(renderer.selection.sid);

					if (collision) {

						x = collision.location.x;
						y = collision.location.y;

					} else {

						return;		// Return in the normal case.

					}
				}

			} else {

				return;				// Return due to unknown selection type.

			}

			let [i, j] = renderer.offset_adjust(x, y);

			i = i * renderer.box_width() + renderer.box_width() / 2;
			j = j * renderer.box_height() + renderer.box_height() / 2;

			context.setLineDash([5, 15]);

			context.lineWidth = 1;
			context.strokeStyle = "#cccccc";

			context.beginPath();
			context.moveTo(i, j);
			context.lineTo(i, 0);
			context.stroke();

			context.beginPath();
			context.moveTo(i, j);
			context.lineTo(i, canvas.height);
			context.stroke();

			context.beginPath();
			context.moveTo(i, j);
			context.lineTo(0, j);
			context.stroke();

			context.beginPath();
			context.moveTo(i, j);
			context.lineTo(canvas.width, j);
			context.stroke();

			context.setLineDash([]);
		};

		renderer.box_width = () => {
			if (renderer.width <= 0) return 1;
			return Math.max(1, canvas.width / renderer.width);
		};

		renderer.box_height = () => {
			if (renderer.height <= 0) return 1;
			return Math.max(1, canvas.height / renderer.height);
		};

		// --------------------------------------------------------------

		renderer.game_length = () => {
			if (!renderer.game) return 0;
			return renderer.game.full_frames.length;
		};

		renderer.players = () => {
			if (!renderer.game) return 0;
			return renderer.game.players.length;
		};

		// --------------------------------------------------------------

		renderer.frame = (n) => {

			// Returns frame n, or if out of bounds, the first or last frame.

			if (!renderer.game) return null;
			if (n >= renderer.game_length()) n = renderer.game_length() - 1;
			if (n < 0) n = 0;
			return renderer.game.full_frames[n];
		};

		renderer.current_frame = () => {
			if (!renderer.game) return null;
			return renderer.frame(renderer.turn);
		};

		renderer.previous_frame = () => {
			if (!renderer.game) return null;
			return renderer.frame(renderer.turn - 1);
		};

		// --------------------------------------------------------------

		renderer.ship_at = (x, y) => {

			// Returns our ship info object, not the original ship.
			// Returns null if no ship present at x,y.

			for (let pid = 0; pid < renderer.players(); pid++) {

				let some_ships = renderer.current_frame().entities[pid];

				if (some_ships === undefined) {
					continue;
				}

				for (let [sid, ship] of Object.entries(some_ships)) {

					if (ship.x === x && ship.y === y) {

						let ret = Object.create(null);

						ret.sid = parseInt(sid, 10);			// sid above will be a string
						ret.pid = pid;
						ret.x = ship.x;
						ret.y = ship.y;
						ret.energy = ship.energy;
						ret.is_inspired = ship.is_inspired;

						return ret;
					}
				}
			}

			return null;
		};

		renderer.ship_info = (sid) => {

			// Returns our ship info object, not the original ship.
			// Returns null if ship not present this frame.

			let pid = renderer.sid_pid_map[sid];
			let some_ships = renderer.current_frame().entities[pid];

			if (some_ships === undefined) {
				return null;
			}

			let hit = some_ships[sid];

			if (!hit) {
				return null;
			}

			let ret = Object.create(null);

			ret.sid = sid;
			ret.pid = pid;
			ret.x = hit.x;
			ret.y = hit.y;
			ret.energy = hit.energy;
			ret.is_inspired = hit.is_inspired;

			return ret;
		};

		renderer.ship_move = (sid) => {

			let lookups = {"n": "up", "s": "down", "e": "right", "w": "left", "o": "&ndash;"};

			let pid = renderer.sid_pid_map[sid];
			let some_moves = renderer.current_frame().moves[pid];

			if (some_moves === undefined) {
				return lookups["o"];
			}

			for (let n = 0; n < some_moves.length; n++) {

				let move = some_moves[n];

				if (move.type === "m" && move.id === sid) {
					return lookups[move.direction];
				}
			}

			return lookups["o"];
		};

		renderer.ship_count = (pid) => {

			if (!renderer.game) return 0;

			let frame = renderer.current_frame();

			let some_ships = frame.entities[pid];

			if (some_ships === undefined) {
				return 0;
			}

			return Object.values(some_ships).length;
		};

		renderer.transit_count = (pid) => {

			if (!renderer.game) return 0;

			let frame = renderer.current_frame();

			let some_ships = frame.entities[pid];

			if (some_ships === undefined) {
				return 0;
			}

			let count = 0;

			for (let ship of Object.values(some_ships)) {
				count += ship.energy;
			}

			return count;
		};

		// --------------------------------------------------------------

		renderer.click = (event) => {

			if (!renderer.game) {
				return;
			}

			let x = Math.floor(event.offsetX / renderer.box_width());
			let y = Math.floor(event.offsetY / renderer.box_height());

			if (x < 0) x = 0;
			if (y < 0) y = 0;
			if (x >= renderer.width) x = renderer.width - 1;
			if (y >= renderer.height) y = renderer.height - 1;

			[x, y] = renderer.offset_adjust(x, y, true);

			renderer.select_at(x, y);

			renderer.draw();
		};

		renderer.select_at = (x, y) => {

			if (!renderer.game) return;
			if (x < 0 || y < 0 || x >= renderer.width || y >= renderer.height) return;

			let ship_info = renderer.ship_at(x, y);

			if (!ship_info) {
				renderer.selection = {type: "box", x: x, y: y};
				return;
			}

			// User clicked a ship, but in the event that we've already
			// selected the ship, select the box underneath it instead.

			if (renderer.selection && renderer.selection.type === "ship" && renderer.selection.sid === ship_info.sid) {
				renderer.selection = {type: "box", x: x, y: y};
				return;
			}

			renderer.selection = {type: "ship", turn: renderer.turn, sid: ship_info.sid, pid: ship_info.pid};
			return;
		};

		// --------------------------------------------------------------

		renderer.log_lines = () => {
			/*
			This is the expected logs object format.
			
			renderer.logs = {
				"1": {
					"-1": ["This is a line that belongs to no ship"]
				},
				"2": {
					"1": [
						"This belongs to ship 1",
						"This belongs to ship as well"
					],
					"0": ["This belongs to ship 0."]
				}
			};*/
			if (renderer.logs === undefined) {
				return;
			}
			
			if (renderer.logs === null) {
				content.innerHTML = "No corresponding log file.";
				return;
			}
			
			let lines = renderer.logs[renderer.turn];
			if (lines) {
				if (renderer.selection && renderer.selection.type === "ship") {
					lines = lines[renderer.selection.sid];
				} else {
					lines = lines[-1];
				}
			}
			
			if (lines) {
				content.innerHTML = lines.join("<br>");
			} else {
				content.innerHTML = "";
			}
			
		}
		
		renderer.send_info = () => {

			if (!renderer.game) return;

			let lines = [];

			lines.push(`<p>${renderer.selection_string()}</p>`);
			lines.push(`<p><br></p>`);

			lines.push(`<p>${path.basename(renderer.filename)}</p>`);
			lines.push(`<p>${renderer.width} x ${renderer.height} &ndash; ${renderer.turn} / ${renderer.game_length() - 1}</p>`);

			for (let pid = 0; pid < renderer.players(); pid++) {

				let deposited = renderer.previous_frame().deposited[pid];
				let initial = renderer.game.GAME_CONSTANTS.INITIAL_ENERGY;
				let current = renderer.previous_frame().energy[pid];
				let spent = deposited + initial - current;

				let rank = renderer.game.game_statistics.player_statistics[pid].rank;
				let rank_nice = `(${ranks[rank]})`;

				let colour = colours[pid];
				lines.push(`<h2 style="color: ${colour}">${renderer.game.players[pid].name} ${rank_nice}</h2>`);
				lines.push(`<ul>`);
				lines.push(`<li>Ships: ${renderer.ship_count(pid)} &ndash; carrying ${renderer.transit_count(pid)}</li>`);
				lines.push(`<li>Deposits: ${deposited + initial}</li>`);
				lines.push(`<li>Spent: ${spent > 0 ? "-" : ""}${spent}</li>`);
				lines.push(`<li>Net: <span style="color: ${colour}">${current}</span></li>`);
				lines.push(`</ul>`);
			}

			infobox.innerHTML = lines.join("");
		};

		return renderer;
	}

	let renderer = make_renderer();

	ipcRenderer.on("open", (event, filename) => {
		renderer.open(filename);
	});

	ipcRenderer.on("save", (event, filename) => {
		renderer.save(filename);
	});

	ipcRenderer.on("save_frame", (event, filename) => {
		renderer.save_frame(filename);
	});

	ipcRenderer.on("save_entities", (event, filename) => {
		renderer.save_entities(filename);
	});

	ipcRenderer.on("save_moves", (event, filename) => {
		renderer.save_moves(filename);
	});

	ipcRenderer.on("forward", (event, n) => {
		renderer.forward(n);
	});

	ipcRenderer.on("right", (event, n) => {
		renderer.right(n);
	});

	ipcRenderer.on("down", (event, n) => {
		renderer.down(n);
	});

	ipcRenderer.on("toggle", (event, varname) => {
		renderer.toggle(varname);
	});

	ipcRenderer.on("set", (event, foo) => {
		renderer.set(foo[0], foo[1]);			// Format is [varname, value]
	});

	ipcRenderer.on("log", (event, msg) => {
		console.log(msg);
	});

	window.addEventListener("resize", () => renderer.draw());

	canvas.addEventListener("mousedown", (event) => renderer.click(event));

	// Setup drag-and-drop...

	window.ondragover = () => false;
	window.ondragleave = () => false;
	window.ondragend = () => false;
	window.ondrop = (event) => {
		event.preventDefault();
		renderer.open(event.dataTransfer.files[0].path);
		ipcRenderer.send("show_window", "renderer");
		return false;
	};

	renderer.clear();

	// Give the window and canvas a little time to settle... (may prevent sudden jerk during load).

	setTimeout(() => {
		ipcRenderer.send("renderer_ready", null);
	}, 200);

</script>
</body>
</html>
